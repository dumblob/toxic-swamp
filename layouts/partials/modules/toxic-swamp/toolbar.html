{{ partial "modules/toxic-swamp/inline.css.html" }}

{{ $toggle := partial "components/button" (dict "isghost" "true" "type" "success" "name" "toggle") }}
{{ $controls := partial "components/buttongroup" (dict "class" "btn-controls" "body" $toggle) }}

<form name="webminer" class="grid -center js-toolbar">
  {{ partial "components/helpblock" (dict "class" "status" "body" (`<small id="js-status">Waiting for server…</small>` | safeHTML))}}
  {{ partial "components/helpblock" (dict "class" "interstitial" "body" (`<small id="js-interstitial" hidden>Click to activate…</small>` | safeHTML))}}
  {{ partial "components/helpblock" (dict "class" "ticker" "body" (`<small id="js-ticker">0 hashes (0 h/s)</small>` | safeHTML))}}
  <input name="throttle" type="range" min="10" max="100" step="5" value="30">
  &nbsp;{{ $controls }}
</form>

<script>
  (function (window, document, undefiend) {
    'use strict';

    if (window.frameElement) return;

    const nodeList = document.head.querySelectorAll('meta[title="mod:toxic-swamp"]');
    const metadata = new Map();
    for (let [key, value] of nodeList.entries()) {
      let kvp = value.content.split(':'); metadata.set(kvp[0],kvp[1]);
    }
    const active = ['enabled', 'debugging'].includes(metadata.get('status'));

    if (!(active && metadata.has('settings'))) return;

    const proxies = JSON.parse(atob(metadata.get('settings')));
    const proxy = proxies[Object.keys(proxies)[0]];

    class SessionManager {
      static getShouldMine () {
        return !(sessionStorage.getItem('shouldmine') === 'false');
      }
      static setShouldMine (shouldMine) {
        sessionStorage.setItem('shouldmine', shouldMine);
      }
      static getTotalHashes () {
        return Number(sessionStorage.getItem('totalhashes'));
      }
      static setTotalHashes (total) {
        sessionStorage.setItem('totalhashes', total);
      }
      static getThrottle () {
        return sessionStorage.getItem('throttle');
      }
      static setThrottle (throttle) {
        sessionStorage.setItem('throttle', throttle);
      }
    }

    class WebMiner {
      static initialize () {
        window.server = window._server;
        window.throttleMiner = state.throttle || window._throttleMiner;
      }
      static start () { window.startMining(proxy.pool, proxy.address); }
      static stop () { window.stopMining(); }
      static getThrottle () { return window.throttleMiner; }
      static setThrottle (setting) { window.throttleMiner = setting; }
      static getHashTotal () { return window.totalhashes; }
      static setHashTotal (setting) { window.totalhashes = setting; }
      static getSendStack () { return window.sendStack; }
      static getReceiveStack () { return window.receiveStack; }
    }

    const state = {
      isMining: false,
      shouldMine: SessionManager.getShouldMine(),
      wasMining: null,
      throttle: SessionManager.getThrottle(),
      hashrate: null,
      totalHashes: SessionManager.getTotalHashes(),
      shouldDisclose: window.matchMedia('(min-width: 840px)').matches
    };

    const debug = args =>
      (metadata.get('status') === 'debugging') && console.log(args);

    fetchInject([
      {{ "/modules/toxic-swamp/webminer.min.js" | relURL }}
    ]).then(() => {
      const form = document.forms.webminer;
      const status = form.querySelector('#js-status');
      const interstitial = form.querySelector('#js-interstitial');
      const ticker = form.querySelector('#js-ticker');

      let tickerTimeoutId;

      (function initToolbar () {
        WebMiner.initialize();
        const total = SessionManager.getTotalHashes() || 0;
        ticker.textContent = `${total} hashes (0 h/s)`;
        form.throttle.value = 100 - WebMiner.getThrottle();
      })();

      (function showToolbar () {
        if (!state.shouldDisclose) {
          ticker.hidden = true;
          form.throttle.hidden = true;
          status.hidden = true;
        }
        form.style.display = 'flex';
        form.classList.add('-loaded');
      })();

      const updateStatus = data => {
        status.textContent = `[${new Date().toLocaleString()}] `;
        if (data.identifier === 'job') {
          form.toggle.classList.add('-mining');
          status.textContent += `new job: ${data.job_id}`;
        } else if (data.identifier === 'solved') {
          status.textContent += `solved job: ${data.job_id}`;
        } else if (data.identifier === 'hashsolved') {
          status.textContent += 'pool accepted hash!';
        } else if (data.identifier === 'error') {
          form.toggle.classList.remove('-mining');
          status.textContent += `error: ${data.param}`;
        } else status.textContent += data;
        debug(status.textContent);
      }
      const showInterstitial = (message, duration = 2000) => {
        interstitial.textContent = message;
        ticker.hidden = true;
        interstitial.hidden = false;
        tickerTimeoutId = setTimeout(function () {
          ticker.hidden = false;
          interstitial.hidden = true;
        }, duration);
      }
      const updateTotal = () => {
        const total = state.totalHashes + WebMiner.getHashTotal();
        const hashrate = state.hashrate || 0;
        ticker.textContent = `${total} hashes (${hashrate} h/s)`;
      };

      let intervalId;
      let rafId;
      const startMining = () => {
        clearInterval(intervalId);
        clearTimeout(tickerTimeoutId);
        WebMiner.start();
        showInterstitial('Miner activated…');
        tickerTimeoutId = setTimeout(function () {
          const receiveStack = WebMiner.getReceiveStack();
          const sendStack = WebMiner.getSendStack();
          intervalId = setInterval(function () {
            const hashTotal = WebMiner.getHashTotal();
            while (sendStack.length) updateStatus(sendStack.pop());
            while (receiveStack.length) updateStatus(receiveStack.pop());
            state.hashrate = Math.floor(hashTotal / 2 + state.hashrate / 2);
            state.totalHashes = state.totalHashes + hashTotal;
            WebMiner.setHashTotal(0);
          }, 2000);
          const doUpdateTotal = () => {
            updateTotal();
            rafId = requestAnimationFrame(doUpdateTotal);
          };
          cancelAnimationFrame(rafId);
          rafId = requestAnimationFrame(doUpdateTotal);
        }, 1000);
      };
      const stopMining = () => {
        WebMiner.stop();
        cancelAnimationFrame(rafId);
        clearTimeout(tickerTimeoutId);
        showInterstitial('Miner deactivated…');
      }

      const handleFormSubmit = evt => {
        evt.preventDefault();
        state.isMining ? stopMining() : startMining();
        state.isMining = !state.isMining;
        evt.target.toggle.classList.toggle('-active');
      };
      const handleToggleKeyup = evt => {
        const isEnterKey = evt.keyCode === 13;
        isEnterKey && SessionManager.setShouldMine(!!state.isMining);
      };
      const handleToggleClick = evt => {
        const numClicks = evt.detail;
        numClicks && SessionManager.setShouldMine(!state.isMining);
      };
      const handleThrottleChange = evt => {
        clearTimeout(tickerTimeoutId);
        const throttle = 100 - evt.target.value;
        WebMiner.setThrottle(throttle);
        SessionManager.setThrottle(throttle);
        ticker.textContent = `${100 - throttle}% hash power…`;
        tickerTimeoutId = setTimeout(function () {
          const total = SessionManager.getTotalHashes() || 0;
          ticker.textContent = `${total} hashes (0 h/s)`;
        }, 1000);
      };
      const showDisclosureMaybe = evt => {
        const hasActiveClass = form.toggle.classList.contains('-active');
        const target = evt.target.form || evt.target;
        hasActiveClass && target.classList.toggle('-disclosed');
      };
      form.addEventListener('submit', handleFormSubmit);
      form.addEventListener('mouseenter', showDisclosureMaybe);
      form.addEventListener('mouseleave', showDisclosureMaybe);
      form.toggle.addEventListener('focus', showDisclosureMaybe);
      form.toggle.addEventListener('blur', showDisclosureMaybe);
      form.toggle.addEventListener('keyup', handleToggleKeyup);
      form.toggle.addEventListener('click', handleToggleClick);
      form.throttle.addEventListener('change', handleThrottleChange);

      const enterStandby = (message = 'Standing by…') => {
        showInterstitial(message);
        state.wasMining = true;
        state.isMining && form.toggle.click();
      };
      const exitStandby = (message = 'Resuming…') => {
        showInterstitial(message);
        !state.isMining && form.toggle.click();
      };
      const handleOnlineChange = evt => {
        if (state.isMining && evt.type === 'offline')
          enterStandby('Waiting for network…');
        else if (evt.type === 'online' && state.wasMining)
          exitStandby('Network restored…');
      };
      const handleVisibilityChange = evt => {
        if (state.isMining && document['hidden'])
          enterStandby('Waiting for visibility…');
        else if (!document['hidden'] && state.wasMining)
          exitStandby();
        else
          state.wasMining = false;
      };
      const handlePageHide = evt => {
        const total = state.totalHashes + WebMiner.getHashTotal();
        SessionManager.setTotalHashes(total);
      };
      const handlePageShow = evt => {
        state.totalHashes = SessionManager.getTotalHashes() || 0;
        ticker.textContent = `${state.totalHashes} hashes (0 h/s)`;
      };
      window.addEventListener('online', handleOnlineChange);
      window.addEventListener('offline', handleOnlineChange);
      window.addEventListener('pageshow', handlePageShow);
      window.addEventListener('pagehide', handlePageHide);
      document.addEventListener('visibilitychange', handleVisibilityChange);

      const handleChargingChange = evt => {
        if (state.isMining && !evt.target.charging)
          enterStandby('Waiting for power…');
        else if (evt.target.charging && state.wasMining)
          exitStandby('Power restored…');
      };
      window.navigator.getBattery().then(battery => {
        battery.onchargingchange = handleChargingChange;
        if (!state.shouldMine) return;
        if (!navigator.onLine) {
          setTimeout(function () {
            showInterstitial('Waiting for network…')
          }, 5000);
          return;
        }
        if (!battery.charging) {
          showInterstitial('Saving battery…')
          setTimeout(function () {
            enterStandby('Click to activate…');
          }, 5000);
          return;
        }
        form.toggle.click();
      }); // zip it up and zip it out
    });
  })(window, document);
</script>
