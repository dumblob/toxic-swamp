{{ partial "modules/toxic-swamp/inline.css.html" }}

{{ $toggle := partial "components/button" (dict "isghost" "true" "type" "success" "name" "toggle") }}
{{ $controls := partial "components/buttongroup" (dict "class" "btn-controls" "body" $toggle) }}

<form hidden name="webminer" class="grid -center js-toolbar">
  {{ partial "components/helpblock" (dict "class" "status" "body" (`<small id="js-status"></small>` | safeHTML))}}
  {{ partial "components/helpblock" (dict "class" "interstitial" "body" (`<small id="js-interstitial" hidden>Click to activate…</small>` | safeHTML))}}
  {{ partial "components/helpblock" (dict "class" "ticker" "body" (`<small id="js-ticker"></small>` | safeHTML))}}
  <input name="throttle" type="range" min="10" max="100" step="5" value="30">
  &nbsp;{{ $controls }}
</form>
<noscript>
  <style>form[name="webminer"] { display: none !important; }</style>
</noscript>

<script>
  (function (window, document, undefiend) {
    'use strict';

    if (window.frameElement) return;

    const nodeList = document.head.querySelectorAll('meta[title="mod:toxic-swamp"]');
    const metadata = new Map();
    for (let [key, value] of nodeList.entries()) {
      let kvp = value.content.split(':'); metadata.set(kvp[0],kvp[1]);
    }
    const active = ['enabled', 'debugging'].includes(metadata.get('status'));

    if (!(active && metadata.has('settings'))) return;

    const proxies = JSON.parse(atob(metadata.get('settings')));
    const proxy = proxies[Object.keys(proxies)[0]];

    class SessionManager {
      static getShouldMine () {
        return !(sessionStorage.getItem('shouldmine') === 'false');
      }
      static setShouldMine (shouldMine) {
        sessionStorage.setItem('shouldmine', shouldMine);
      }
      static getTotalHashes () {
        return Number(sessionStorage.getItem('totalhashes'));
      }
      static setTotalHashes (total) {
        sessionStorage.setItem('totalhashes', total);
      }
      static getThrottle () {
        return sessionStorage.getItem('throttle');
      }
      static setThrottle (throttle) {
        sessionStorage.setItem('throttle', throttle);
      }
    }

    class WebMiner {
      static initialize () {
        window.server = window._server;
        window.throttleMiner = state.throttle || window._throttleMiner;
      }
      static start () { window.startMining(proxy.pool, proxy.address); }
      static stop () { window.stopMining(); }
      static getThrottle () { return window.throttleMiner; }
      static setThrottle (setting) { window.throttleMiner = setting; }
      static getHashTotal () { return window.totalhashes; }
      static setHashTotal (setting) { window.totalhashes = setting; }
      static getSendStack () { return window.sendStack; }
      static getReceiveStack () { return window.receiveStack; }
    }

    const state = {
      isMining: false,
      shouldMine: SessionManager.getShouldMine(),
      throttle: SessionManager.getThrottle(),
      hashrate: null,
      totalHashes: SessionManager.getTotalHashes(),
      shouldDisclose: window.matchMedia('(min-width: 840px)').matches
    };

    if (state.throttle) {
      document.forms.webminer.throttle.value = 100 - state.throttle;
    }

    const debug = args =>
      (metadata.get('status') === 'debugging') && console.log(args);

    fetchInject([
      {{ "/modules/toxic-swamp/webminer.min.js" | relURL }}
    ]).then(() => {
      const form = document.forms.webminer;
      const status = form.querySelector('#js-status');
      const interstitial = form.querySelector('#js-interstitial');
      const ticker = form.querySelector('#js-ticker');

      class Miner {
        static activate (shouldPersist = false) {
          state.isMining = true;
          startMining();
          shouldPersist && (() => {
            SessionManager.setShouldMine(true);
            showInterstitial('Miner activated…');
          })();
        }
        static deactivate (shouldPersist = false) {
          state.isMining = false;
          stopMining();
          shouldPersist && (() => {
            SessionManager.setShouldMine(false);
            showInterstitial('Miner deactivated…');
          })();
        }
        static getActiveStatus () {
          return state.isMining ? 'active' : 'inactive';
        }
      }

      class Toolbar {
        static initialize () {
          WebMiner.initialize();
          const total = SessionManager.getTotalHashes() || 0;
          ticker.textContent = `${total} hashes (0 h/s)`;
          form.throttle.value = 100 - WebMiner.getThrottle();
        }
        static togglePower (wasUserInitiated = false) {
          const isMinerActive = Miner.getActiveStatus() === 'active';
          const isDeviceOnline = navigator.onLine;
          isMinerActive
            ? Miner.deactivate(wasUserInitiated) && Toolbar.toggleStatusbar()
            : Miner.activate(wasUserInitiated);
          form.toggle.classList.toggle('-active');
          isDeviceOnline
            ? updateStatus('waiting for server')
            : updateStatus('waiting for network');
        }
        static setThrottle (throttle) {
          WebMiner.setThrottle(100 - throttle);
          SessionManager.setThrottle(100 - throttle);
          showInterstitial(`${throttle}% hash power…`);
        }
        static setDisplayMode (displayMode = 'full') {
          const isValidMode = [
            'full', 'compact', 'hidden', 'minimal'
          ].includes(displayMode);
          if (!isValidMode) throw new Error(`Toolbar expected display mode of 'full', 'compact', 'minimal' or 'hidden': '${displayMode}' received`);
          Toolbar.displayMode = displayMode;
          Toolbar.updateDisplay();
        }
        static getDisplayMode () {
          return Toolbar.displayMode;
        }
        static updateDisplay () {
          const displayMode = Toolbar.displayMode;
          const shouldMine = SessionManager.getShouldMine();
          const visibleItems = new Set([
            form, ticker, status, form.toggle, form.throttle
          ]);
          let hiddenItems;
          switch (displayMode) {
            case 'full':
              hiddenItems = shouldMine ? [] : [].concat(ticker);
              break;
            case 'compact':
              hiddenItems = [].concat([form, ticker, status]);
              break;
            case 'minimal':
              hiddenItems = [].concat([form, ticker, status, form.throttle]);
              break;
            case 'hidden':
              hiddenItems = [].concat(
                [form, ticker, status, form.toggle, form.throttle]
              );
              break;
          }
          hiddenItems.forEach(hiddenItem => {
            hiddenItem.hidden = true;
            visibleItems.delete(hiddenItem);
          });
          visibleItems.forEach(visibleItem => {
            visibleItem.hidden = false;
          });
        }
        static toggleStatusbar () {
          const isMinerActive = Miner.getActiveStatus() === 'active';
          isMinerActive
            ? form.classList.toggle('-disclosed')
            : form.classList.remove('-disclosed');
        }
        static registerListeners () {
          form.addEventListener(
            'submit', evt => evt.preventDefault()
          );
          form.throttle.addEventListener(
            'change', evt => Toolbar.setThrottle(evt.target.value)
          );
          form.toggle.addEventListener(
            'keyup', evt => evt.keyCode === 13 && Toolbar.togglePower(true)
          );
          form.toggle.addEventListener(
            'click', evt => evt.detail && Toolbar.togglePower(true)
          );
          form.toggle.addEventListener(
            'mouseenter', evt => Toolbar.toggleStatusbar()
          );
          form.toggle.addEventListener(
            'mouseleave', evt => Toolbar.toggleStatusbar()
          );
          form.toggle.addEventListener(
            'focus', evt => Toolbar.toggleStatusbar()
          );
          form.toggle.addEventListener(
            'blur', evt => Toolbar.toggleStatusbar()
          );
        }
      }
      const displaySetting = state.shouldDisclose ? 'full' : 'compact';

      Toolbar.initialize();
      Toolbar.setDisplayMode(displaySetting);
      Toolbar.registerListeners();

      const updateStatus = data => {
        status.textContent = `[${new Date().toLocaleString()}] `;
        if (data.identifier === 'job') {
          form.toggle.classList.add('-mining');
          status.textContent += `new job: ${data.job_id}`;
        } else if (data.identifier === 'solved') {
          status.textContent += `solved job: ${data.job_id}`;
        } else if (data.identifier === 'hashsolved') {
          status.textContent += 'pool accepted hash!';
        } else if (data.identifier === 'error') {
          form.toggle.classList.remove('-mining');
          status.textContent += `error: ${data.param}`;
        } else status.textContent += data;
        debug(status.textContent);
      };
      const showInterstitial = (message, delay = 0) => {
        setTimeout(function () {
          interstitial.textContent = message;
          ticker.hidden = true;
          interstitial.hidden = false;
          setTimeout(function () {
            ticker.hidden = false;
            interstitial.hidden = true;
          }, 2000);
        }, delay);
      };
      const updateTotal = () => {
        const total = state.totalHashes + WebMiner.getHashTotal();
        const hashrate = state.hashrate || 0;
        ticker.textContent = `${total} hashes (${hashrate} h/s)`;
      };

      let intervalId;
      let rafId;
      const startMining = () => {
        cancelAnimationFrame(rafId);
        clearTimeout(intervalId);
        WebMiner.start();
        const receiveStack = WebMiner.getReceiveStack();
        const sendStack = WebMiner.getSendStack();
        intervalId = setInterval(function () {
          const hashTotal = WebMiner.getHashTotal();
          while (sendStack.length) updateStatus(sendStack.pop());
          while (receiveStack.length) updateStatus(receiveStack.pop());
          state.hashrate = Math.floor(hashTotal / 2 + state.hashrate / 2);
          state.totalHashes = state.totalHashes + hashTotal;
          WebMiner.setHashTotal(0);
        }, 1000);
        const doUpdateTotal = () => {
          updateTotal();
          rafId = requestAnimationFrame(doUpdateTotal);
        };
        rafId = requestAnimationFrame(doUpdateTotal);
      };
      const stopMining = () => {
        WebMiner.stop();
        setInterval(function () {
          if (state.hashrate != 0) return;
          cancelAnimationFrame(rafId);
          clearInterval(intervalId);
        }, 1000);
      }

      const handleChargingChange = evt => {
        const shouldMine = SessionManager.getShouldMine();
        if (!shouldMine) return;
        const isMinerActive = Miner.getActiveStatus() === 'active';
        const startedCharging = evt.target.charging;
        const isDeviceOnline = navigator.onLine;
        if (startedCharging) {
          const isDeviceOnline = navigator.onLine;
          showInterstitial('Device powered…');
          !isMinerActive && Toolbar.togglePower()
          if (isDeviceOnline) {
            showInterstitial('Mining resumed…', 3000);
          } else {
            updateStatus('waiting for network');
            showInterstitial('Network disconnected…', 3000);
          }
        } else {
          showInterstitial('Power unplugged…');
          isMinerActive && Toolbar.togglePower();
          isDeviceOnline
            ? showInterstitial('Saving battery…', 3000)
            : showInterstitial('Network disconnected…', 3000);
        }
      };
      const handleOnlineChange = evt => {
        const shouldMine = SessionManager.getShouldMine();
        if (!shouldMine) return;
        const isMinerActive = Miner.getActiveStatus() === 'active';
        const wentOnline = evt.type === 'online';
        if (wentOnline) {
          showInterstitial('Device online…');
          if (isMinerActive) {
            updateStatus('waiting for server');
            showInterstitial('Mining resumed…', 3000);
          } else {
            showInterstitial('Click to activate…', 3000);
          }
        } else {
          showInterstitial('Device went offline…');
          if (isMinerActive) {
            updateStatus('waiting for network');
            showInterstitial('Miner on standby…', 3000);
          } else {
            showInterstitial('Mining paused…', 3000);
          }
        }
      };
      const handleVisibilityChange = evt => {
        const shouldMine = SessionManager.getShouldMine();
        if (!shouldMine) return;
        const isMinerActive = Miner.getActiveStatus() === 'active';
        const wasDocumentHidden = document['hidden'];
        if (wasDocumentHidden) {
          isMinerActive && Toolbar.togglePower();
        } else {
          navigator.getBattery().then(battery => {
            const isDeviceCharging = battery.charging;
            if (isDeviceCharging) {
              !isMinerActive && Toolbar.togglePower();
            } else {
              showInterstitial('Saving battery…');
              showInterstitial('Click to override…', 3000);
            }
          });
        }
      };
      const handlePageHide = evt => {
        const total = state.totalHashes + WebMiner.getHashTotal();
        SessionManager.setTotalHashes(total);
      };
      const handlePageShow = evt => {
        state.totalHashes = SessionManager.getTotalHashes() || 0;
        ticker.textContent = `${state.totalHashes} hashes (0 h/s)`;
      };

      window.addEventListener('online', handleOnlineChange);
      window.addEventListener('offline', handleOnlineChange);
      window.addEventListener('pageshow', handlePageShow);
      window.addEventListener('pagehide', handlePageHide);
      document.addEventListener('visibilitychange', handleVisibilityChange);

      navigator.getBattery().then(battery => {
        battery.onchargingchange = handleChargingChange;
        const shouldMine = SessionManager.getShouldMine();
        if (!shouldMine) return;
        const isDeviceOnline = navigator.onLine;
        const isDeviceCharging = battery.charging;
        if (isDeviceCharging) {
          if (isDeviceOnline) return Toolbar.togglePower();
          showInterstitial('Network disconnected…');
          showInterstitial('Mining suspended…', 3000);
        } else {
          showInterstitial('Power unplugged…');
          showInterstitial('Miner on standby…', 3000);
        }
      }); // zip it up and zip it out
    });
  })(window, document);
</script>
